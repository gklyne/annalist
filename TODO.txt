# Explorations

* Choose web server
  * probably Apache, considering nginx, but deferred until suitable OAuth2/OpenID-connect plugin is available
  * until then, using DJango for everything while ideas are fleshed out
* Authentication mechanism
  * Going with OAuth2/OpenID-Connect for now
  * Currently workingwith Google as IDP; loooking for alternatives
  * Considering OAuth2-Shibboleth bridge for uni deployment (have link somewhere in notes)
* Access control model
  * TBD; expect to use elements from UMA in due course
  * For now have very simple authorization function that requires authentication for up-dates, otherwise open.
* Define on-disk structure
    * Directories
    * Files
    * See https://github.com/gklyne/annalist/blob/develop/src/annalist_site/annalist/layout.py
    * @@NOTE: need to wean off direct directory access and use HTTP
* Define data access internal API details for web site
  * First cut in progress
  * @@NOTE: remember to use simple GET semantics where possible; may need to revisist and simplify
* Define UI generation details
* Implement data access API details
  * Mostly straight HTTP GET, etc
* Implement UI generation details
  * The main challenge.
  * Follow mockups per https://github.com/gklyne/annalist/tree/develop/mockup
* Create core UI definitions


## Web application

1. Front page/initial display
   / form elements to create new collection
   / form elements to delete collection
   / include supporting logic in Collection module
   / rework authentication/authorization to allow unauthenticated access for public data 
   / test cases for site, site views; refactor tests to separate directory, modules
   / adopt responsive CSS framework (Foundation)
2. Collection display
   / refactor metadata field access to common superclass
   / types
     / implement skeleton RecordType module
     / create test cases for types in collection
     / implement type methods
   / views
     / implement skeleton RecordView module
     / create test cases for views in collection
     / implement view methods
   / lists
     / implement skeleton RecordList module
     / create test cases for lists in collection
     / implement list methods
   / UI test cases
   / form elements to add/delete types/views/lists/...
   - Add CollectionActionView test cases
3. Record type display
   / template
   / view: edit form display
   / view test cases
   / refactor redirect_info, redirect_error in generic view to takle URI rather than view name parameter,
     and add new method to handle URI generation from view name + params.
   / model
   / model test cases
   / view edit form response handling
   - when renaming through edit form, update URI if it corresponds to previous ID??
   - need to think about maintaining a list of correspopnding URIs?
   - refactor code; try to abstract common logic for RecordList, RecordView
4. Default record list display (code may later be refactored)
5. Design generic entity view
6. Record view display and editing
7. Generic record list display and editing
8. ...

Misc
- Login link to include option to redirect to failed page, with form fields populated
- Complete authorization framework, per collection
/ can "Confirm" form continue to a DELETE operation?  Can forms reliably do this?  NO

- think about use of CURIES in data (e.g. for types, fields, etc.)
- think about handling of identifier renaming (re-write data, record equivalence, or ...).  (See also "data storage" below.)
- Use server-internal revectoring?  What about delete multiple?
- currently there's some inconsistency about this: confirm views are rendered directly (as this allows form parameters to be provided directly), but other form action links are handled by redirection.  Try to be more consistent about this?  Create a more general pattern for handling continuation forms?
- move util.py to utils package, and rename?
- util.write_entity: think about capturing provenance metadata too
- move entity I/O logic in util module to entity module (keep it all together)
? view collections doesn't use entered label - problem with entry vocab? (Fixed?)

Entity abstraction:
- replace direct file access with HTTP access

AnalistGenericView:
- Generic renderers, all driven by a supplied dictionary:
  - HTML
  - JSON-LD
  - uri-list
- but serve native format directly.

Data storage:
- Note that it should be possible to take an Annalist site directory and dump it onto any regular HTTP server to publish the raw data.  Web site should still be able to work with that.
- think about storage of identifier URIs (e.g. record type URIs.)  Should they default to be:
  (1) relative to self
  (2) relative to base of site
  (3) relative to host
  (4) absolute
  Currently, it's (3) or (4), but I think I favour (2).  The intent is that the URI field
  can be fixed by explicitly entering an absolute URI, but until then they are allocated
  per site.  The expectation is that if data are moved, it will be as complete collections
  to ensure they are accompanied by their associated metadata.


Deployment:
- look into using Vagrant and/or Puppet/Chef/...


## Dynamic form interface

(To be planned)


## Authorization

* Assume use of annalist form data under control of suitable authority
* Focus on form of authorization data
* Back-fit to form interface for creation of data; figure what seeding is needed

