## Explorations

* Choose web server
  * probably Apache, considering nginx, but deferred until suitable OAuth2/OpenID-connect plugin is available
  * until then, using DJango for everything while ideas are fleshed out
* Authentication mechanism
  * Going with OAuth2/OpenID-Connect for now
  * Currently workingwith Google as IDP; loooking for alternatives
  * Considering OAuth2-Shibboleth bridge for uni deployment (have link somewhere in notes)
* Access control model
  * TBD; expect to use elements from UMA in due course
  * For now have very simple authorization function that requires authentication for up-dates, otherwise open.
* Define on-disk structure
    * Directories
    * Files
    * See https://github.com/gklyne/annalist/blob/develop/src/annalist_site/annalist/layout.py
    * @@NOTE: need to wean off direct directory access and use HTTP
* Define data access internal API details for web site
  * First cut in progress
  * @@NOTE: remember to use simple GET semantics where possible; may need to revisist and simplify
  * @@TODO: current implementation is file-based, but details are hidden in Entity classes.
* Define UI generation details
* Implement data access API details
  * Mostly straight HTTP GET, etc
* Implement UI generation details
  * The main challenge.
  * Follow mockups per https://github.com/gklyne/annalist/tree/develop/mockup
* Create core UI definitions


## Web application

1. Front page/initial display
   / form elements to create new collection
   / form elements to delete collection
   / include supporting logic in Collection module
   / rework authentication/authorization to allow unauthenticated access for public data 
   / test cases for site, site views; refactor tests to separate directory, modules
   / adopt responsive CSS framework (Foundation)
2. Collection display
   / refactor metadata field access to common superclass
   / types
     / implement skeleton RecordType module
     / create test cases for types in collection
     / implement type methods
   / views
     / implement skeleton RecordView module
     / create test cases for views in collection
     / implement view methods
   / lists
     / implement skeleton RecordList module
     / create test cases for lists in collection
     / implement list methods
   / UI test cases
   / form elements to add/delete types/views/lists/...
   - Add CollectionActionView test cases
3. Record type display
   / template
   / view: edit form display
   / view test cases
   / refactor redirect_info, redirect_error in generic view to takle URI rather than view name parameter,
     and add new method to handle URI generation from view name + params.
   / model
   / model test cases
   / view edit form response handling
   / refactor code locally
   / more refactoring; try to abstract common logic for RecordList, RecordView
   / review generic view base functions - should some be inlined now?
  - Move types/views/lists data into _annalist_collection directory
  - URI (re)design for record display
4. Default record view/edit display (code to be refactored later)
   / form generation
   / form display test cases
   / provision for data access fallback to site data (for types, views, fields, etc.)
   / form response handler
   / test cases
   / refactor URI and test data support for test cases to separate module; use reverse for URI generation; 
   x isolate directory generation for tests.
   - refactor form display
   - include base, path and/or reference values in entities.
   - change <site>/collections/ to <site>/c/ or <site>/coll/ throughout.
   - Similar for /d/ and /data/?
   - create data view display based on generic render logic
5. Default record list display
   - form generation
   - form display test cases
   - form response handler
   - form response test cases
   - connect list display to record view display
6. Design generic entity view
7. Record view display and editing
8. Generic record list display and editing
9. Misc cleanup
  - Login link to include option to redirect to failed page, with form fields populated
  - Complete authorization framework
  - convert to HTTP entity access
  / can "Confirm" form continue to a DELETE operation?  Can forms reliably do this?  NO

X. Future features (see also Misc below)
- spreadhsheet bridge
- Research Object presentation
- more field types, including link browser
- provenance data
- git integration for data versioning
- memento integration for old data recovery
- ResourceSync integration for data sync

Tests required:
- Missing resource error reporting in:
  - annalist/views/collection.py
  - annalist/views/defaultedit.py
  - annalist/views/defaultlist.py
  - annalist/views/recordtype.py

Misc:
- Login link to include option to redirect to failed page, with form fields populated
- Complete authorization framework, per collection
/ can "Confirm" form continue to a DELETE operation?  Can forms reliably do this?  NO

- think about use of CURIES in data (e.g. for types, fields, etc.)  Need to store prefix info with collection.
- think about handling of identifier renaming (re-write data, record equivalence, or ...).  (See also "data storage" below.)
   - when renaming through edit form, update URI if it corresponds to previous ID??
   - need to think about maintaining a list of correspopnding URIs?
- Use server-internal revectoring?  What about delete multiple?
- currently there's some inconsistency about this: confirm views are rendered directly (as this allows form parameters to be provided directly), but other form action links are handled by redirection.  Try to be more consistent about this?  Create a more general pattern for handling continuation forms?    Note: redirect means that different view GET function signatures, with values provided in the request URI, are handled in generic fashion.  POST views are more easily handled directly with form parameters as supplied dictionary
- move util.py to utils package, and rename?
- entity._save: think about capturing provenance metadata too
/ move entity I/O logic in util module to entity module (keep it all together)
? view collections doesn't use entered label - problem with entry vocab? (Fixed?)

Entity abstraction:
- replace direct file access with HTTP access

AnnalistGenericView:
- Generic renderers, all driven by a supplied dictionary:
  - HTML
  - JSON-LD
  - uri-list
- but serve native format directly.

Data storage:
- Note that it should be possible to take an Annalist site directory and dump it onto any regular HTTP server to publish the raw data.  Web site should still be able to work with that.
- think about storage of identifier URIs (e.g. record type URIs.)  Should they default to be:
  (1) relative to self
  (2) relative to base of site
  (3) relative to host
  (4) absolute
  Currently, it's (3) or (4), but I think I favour (2).  The intent is that the URI field
  can be fixed by explicitly entering an absolute URI, but until then they are allocated
  per site.  The expectation is that if data are moved, it will be as complete collections
  to ensure they are accompanied by their associated metadata.


Deployment:
- look into using Vagrant and/or Puppet/Chef/...


## Authorization

* Assume use of annalist form data under control of suitable authority
* Focus on form of authorization data
* Back-fit to form interface for creation of data; figure what seeding is needed

