"""
OAuth2 / OpenID Connect authentication related view handler and
supporting utilities.

NOTE: for Google provider, set up via 
https://console.developers.google.com/apis/dashboard
"""

__author__      = "Graham Klyne (GK@ACM.ORG)"
__copyright__   = "Copyright 2016, G. Klyne"
__license__     = "MIT (http://opensource.org/licenses/MIT)"

import sys
import os
import json
import base64
import re
import traceback
import logging
log = logging.getLogger(__name__)

from requests_oauthlib import OAuth2Session

from django.core.urlresolvers import resolve, reverse
from django.http import HttpResponse
from django.http import HttpResponseRedirect
from django.template import RequestContext, loader
from django.views import generic
from django.views.decorators.csrf import csrf_exempt

from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.models import User

from utils.http_errors import error400values

from login_utils    import HttpResponseRedirectWithQuery, HttpResponseRedirectLogin, object_to_dict
# from models         import CredentialsModel, Storage
import login_message

#@@@@ FLOW_SECRET_KEY = str(uuid.uuid1())

SCOPE_DEFAULT = ["openid", "profile", "email"]

#   ---------------------------------------------------------------------------
#
#   Factory function
#
#   ---------------------------------------------------------------------------

def oauth2_flow_from_provider_data(provider_data, redirect_uri=None, state=None):
    """
    Create an OpenId connect Oauth2 flow object from a supplied provider details file.

    provider_data
            dictionary containing provider details (including oauth2 client secrets).
    redirect_uri
            URI to which control is transferred when the OAuth2 authetication dance 
            is completed.  If specified, overrides value from provider-file.
    """
    return oauth2_flow(provider_data, redirect_uri=redirect_uri, state=state)

#@@@@@@@@@@@@REMOVE?
# def oauth2_get_state_token(request_user):
#     """
#     Get a cross-site request forgery protection token for the current-request user.
#     """
#     return xsrfutil.generate_token(FLOW_SECRET_KEY, request_user)
#@@

#@@@@@@@@@@@@REMOVE?
# def oauth2_flow_to_dict(f):
#     """
#     Convert an OAuth2 flow object to a dictionary.
#     """
#     return object_to_dict(f, OAuth2WebServerFlow_strip) 
#@@

# def oauth2_dict_to_flow(d):
#     """
#     Constructs a OAuth2WebServerFlow object from a dictionary previously 
#     created by oauth2_flow_to_dict.

#     Args:
#         d:  dict, generated by object_to_dict

#     @@TODO: handle multiple flow object types.
#     (Might need django.util.module_loading.import_string)
#     """
#     flow = OAuth2WebServerFlow(
#         d['client_id'], d['client_secret'], d['scope'],
#         redirect_uri=d['redirect_uri'], 
#         user_agent=d['user_agent'],
#         auth_uri=d['auth_uri'], 
#         token_uri=d['token_uri'],
#         revoke_uri=d['revoke_uri'],
#         **d['params']
#         )
#     return flow

#   ---------------------------------------------------------------------------
#
#   Oauth2 flow object (based loosely on oauth2client flow object)
#
#   ---------------------------------------------------------------------------

class oauth2_flow(object):
    """
    Choreographs the oauth2 dance used to obtain a user authetication credential.
    """

    def __init__(self, provider_data, scope=None, state=None, redirect_uri=None):
        """
        Initialize a flow object with supplied provider data (provided as a dictionary)
        """
        self._provider_data = provider_data
        self._scope         = scope or provider_data.get("scope", SCOPE_DEFAULT)
        self._redirect_uri  = redirect_uri or provider_data.get("redirect_uris", [None])[0]
        session             = OAuth2Session(
                                client_id=provider_data["client_id"],
                                scope=self._scope,
                                state=state,
                                redirect_uri=self._redirect_uri
                                )
        auth_uri, state     = session.authorization_url(provider_data["auth_uri"])
        self._session       = session
        self._auth_uri      = auth_uri
        self._state         = state
        return

    def step1_get_state_token(self):
        return self._state

    def step1_get_authorize_url(self):
        return self._auth_uri

    def step2_exchange(self, request):
        """
        Using a credentials provided in the supplied redirect request value,
        requests an access token for user authentication.
        """
        auth_resp = request.build_absolute_uri()
        # log.info("@@@@ auth_resp %s"%(auth_resp))
        token = self._session.fetch_token(self._provider_data['token_uri'], 
            authorization_response=auth_resp,
            # client_id=self._provider_data['client_id'],
            client_secret=self._provider_data['client_secret'],
            timeout=5
            )
        return token

    def step3_get_profile(self, token):
        r = self._session.get(self._provider_data["profile_uri"])
        profile = json.loads(r.content)
        return profile

class OIDC_AuthDoneView(generic.View):
    """
    View class used to complete login process with authorization grant provided by
    OAuth2 authorization server.

    The calling application must set up the URL routing for this handler to be invoked.
    """

    def get(self, request):
        # Look for authorization grant
        provider_data = request.session['login_provider_data']
        state         = request.session['oauth2_state']
        userid        = request.session['oauth2_userid']
        provider      = provider_data['provider']
        flow          = oauth2_flow_from_provider_data(provider_data, state=state)
        # Get authenticated user details
        try:
            credential = flow.step2_exchange(request)
            profile    = flow.step3_get_profile(credential)
            # profile looks like this:
            #
            # { "id": "104756500079491165441",
            #   "email": "graham.klyne@oerc.ox.ac.uk",
            #   "verified_email": true,
            #   "name": "...",
            #   "given_name": "...",
            #   "family_name": "...",
            #   "link": "...",
            #   "picture": "...",
            #   "gender": "..."
            # }
            log.info("auth_oidc_client: userid %s, profile %r"%(userid, profile))
            authuser = authenticate(
                username=userid, profile=profile
                )
            log.info("authuser: %r"%(authuser,))
        except Exception as e:
            log.error("Exception %r"%(e,))
            log.error("provider_data %r"%(provider_data,))
            ex_type, ex, tb = sys.exc_info()
            log.error("".join(traceback.format_exception(ex_type, ex, tb)))
            # log.error("".join(traceback.format_stack()))
            return HttpResponseRedirectLogin(request, str(e))
        # Check authenticated details for user id match any previous values.
        #
        # The user id is entered by the user on the login form, and is used as a key to
        # access authenticated user details in the Django user database.  The user id 
        # itself is not checked by the Oauth2 login flow, other than for checking that
        # it containbs only work characters
        #
        # Instead, we trust that the associated email address has been confirmed by the 
        # OAuth2 provider, and don't allow login where the email adress differs from any 
        # currently saved email address for the user id used..  This aims to  prevent a 
        # new set of OAuth2 credentials being used for a previously created Django user id.
        #
        if not authuser:
            log.info(
                "auth_oidc_client: userid %s, provider %s, profile %r"%
                  (userid, provider, profile)
                )
            return HttpResponseRedirectLogin(request, 
                login_message.USER_NOT_AUTHENTICATED%(userid, provider)
                )
        if not userid:
            # Get generated username
            userid = authuser.username
        if not re.match(r"\w+$", userid):
            return HttpResponseRedirectLogin(
                request, 
                login_message.USER_ID_SYNTAX%(userid)
                )
        if not authuser.email:
            return HttpResponseRedirectLogin(request, 
                login_message.USER_NO_EMAIL%(userid)
                )
        try:
            olduser = User.objects.get(username=userid)
        except User.DoesNotExist:
            olduser = None
        if olduser:
            if authuser.email != olduser.email:
                return HttpResponseRedirectLogin(request, 
                    login_message.USER_WRONG_EMAIL%(userid, authuser.email, olduser.email)
                    )
        # Complete the login and save details
        authuser.save()
        login(request, authuser)
        request.session['login_recent_userid'] = userid
        # storage = Storage(CredentialsModel, 'id', request.user, 'credential')
        # storage.put(credential)
        # Don't normally log the credential/token as they might represent a security leakage:
        # log.debug("OIDC_AuthDoneView: credential:      "+repr(credential.to_json()))
        # log.info("OIDC_AuthDoneView: id_token:        "+repr(credential.id_token))
        log.info("OIDC_AuthDoneView: user.username:   "+authuser.username)
        log.info("OIDC_AuthDoneView: user.first_name: "+authuser.first_name)
        log.info("OIDC_AuthDoneView: user.last_name:  "+authuser.last_name)
        log.info("OIDC_AuthDoneView: user.email:      "+authuser.email)
        return HttpResponseRedirectLogin(request)

# End.
