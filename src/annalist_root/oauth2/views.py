"""
OAuth2 / OpenID Connect authentication related views
"""

__author__      = "Graham Klyne (GK@ACM.ORG)"
__copyright__   = "Copyright 2014, G. Klyne"
__license__     = "MIT (http://opensource.org/licenses/MIT)"

# @@TODO: refactor all OAuth2 details from views to this module
# @@TODO: define a view decorator to apply OAuth2 authentication requirement

import os
import re
import json
import markdown
import copy
import uuid
import urllib
from urlparse import urlparse, urljoin
from importlib import import_module

import logging
log = logging.getLogger(__name__)

import httplib2

from oauth2client.client import OAuth2WebServerFlow
from oauth2client import xsrfutil
from oauth2client.client import flow_from_clientsecrets, FlowExchangeError
from oauth2client.django_orm import Storage

from django.core.urlresolvers import resolve, reverse
from django.http import HttpResponse
from django.http import HttpResponseRedirect
from django.template import RequestContext, loader
from django.views import generic
from django.views.decorators.csrf import csrf_exempt

from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.models import User

from oauth2.djangoauthclient import django_flow_from_user_id


settings = import_module(os.environ["DJANGO_SETTINGS_MODULE"])

from utils.http_errors import error400values

from models import CredentialsModel

# Per-instance generated secret key for CSRF protection via OAuth2 state value.
# Regenerated each time this service is started.
FLOW_SECRET_KEY = str(uuid.uuid1())

PROVIDER_FILES = None

PROVIDER_DETAILS = None

SCOPE_DEFAULT = "openid profile email"

OAuth2WebServerFlow_strip = (
    "step1_get_authorize_url",
    "step2_exchange"
    )

def collect_client_secrets():
    global PROVIDER_FILES, PROVIDER_DETAILS
    if PROVIDER_DETAILS is None:
        PROVIDER_DETAILS = {}
        PROVIDER_FILES   = {}
        clientsecrets_dirname = os.path.join(settings.CONFIG_BASE, "providers/")
        if os.path.isdir(clientsecrets_dirname):
            clientsecrets_files   = os.listdir(clientsecrets_dirname)
            for f in clientsecrets_files:
                p = os.path.join(clientsecrets_dirname,f)
                j = json.load(open(p, "r"))
                n = j['web']['provider']
                PROVIDER_DETAILS[n] = j['web']
                PROVIDER_FILES[n]   = p
    return

def object_to_dict(obj, strip):
    """Utility function that creates dictionary representation of an object.

    Args:
        strip: an array of names of members to not include in the dict.

    Returns:
        dictionary, with non-excluded values that can be used to reconstruct an instance
        of the object via its constructor (assuming an appropriate constructor form, as
        used below for oauth2_dict_to_flow, etc.)
    """
    t = type(obj)
    d = copy.copy(obj.__dict__)
    for member in strip:
      if member in d:
        del d[member]
    d['_class'] = t.__name__
    d['_module'] = t.__module__
    return d

def oauth2_flow_to_dict(f):
    """
    Converty a flow object to a dictionaruy.
    """
    return object_to_dict(f, OAuth2WebServerFlow_strip) 

def oauth2_dict_to_flow(d):
    """
    Constructs a OAuth2WebServerFlow object from a dictionary previously created
    by oauth2_flow_to_dict.

    Args:
        d:  dict, generated by object_to_dict

    @@TODO: handle multiple flow object types.
    (Might need django.util.module_loading.import_string)
    """
    flow = OAuth2WebServerFlow(
        d['client_id'], d['client_secret'], d['scope'],
        redirect_uri=d['redirect_uri'], 
        user_agent=d['user_agent'],
        auth_uri=d['auth_uri'], 
        token_uri=d['token_uri'],
        revoke_uri=d['revoke_uri'],
        **d['params']
        )
    return flow

def _untested_authentication_required(
        login_form_url=None, login_post_url=None, login_done_url=None, 
        continuation_url=None, scope=SCOPE_DEFAULT):
    """
    Decorator for view handler function that activates OAuth2 authentication flow
    if the current request is not already associated with an authenticated user.
    """
    # @@NOTE: not tested; the mix of static and dynamic parameters required makes
    #         the in-line form easier to use than a decorator.
    def decorator(func):
        def guard(view, values):
            return (
                confirm_authentication(view, 
                    login_form_url, login_post_url, login_done_url, 
                    continuation_url, scope)
            or
                func(view, values)
            )
        return guard
    return decorator

def HttpResponseRedirectWithQuery(redirect_uri, query_params):
    nq = "?"
    for pname in query_params.keys():
        if query_params[pname]:
            redirect_uri += nq + pname + "=" + urllib.quote(query_params[pname])
            nq = "&"
    # log.info("redirect_uri: "+redirect_uri)
    return HttpResponseRedirect(redirect_uri)

def HttpResponseRedirectLoginWithMessage(request, message, userid=None):
    login_form_url = request.session['login_form_url']
    log.info("login_form_url: "+login_form_url)
    query_params = (
        { "continuation_url": request.session['continuation_url']
        , "scope":            request.session['oauth2_scope']
        , "error_head":       "Login failed"
        , "error_message":    message
        , "userid":           userid
        })
    return HttpResponseRedirectWithQuery(login_form_url, query_params)

def confirm_authentication(view, 
        login_form_url=None, login_post_url=None, login_done_url=None, 
        user_profile_url=None, continuation_url=None, 
        scope=SCOPE_DEFAULT, 
        help_path="annalist/views/help/"):
    """
    Return None if required authentication is present, otherwise
    a login redirection response to the supplied URI

    view.credential is set to credential that can be used to access resource

    Five URL parameters are passed in from the calling application:

    login_form_url      Page to gather information to initiate login process
    login_post_url      URL to which login information is posted
    login_done_url      URL retrieved with additional parameters when authentication
                        is complete (maybe failed). In the OAuth2 flow, this triggers
                        retrieval of user profile information.  Not used for local
                        authentication.
    user_profile_url    URL retrieved when user profile details have been set up.
    continuation_url    URL from which the login process was initiated.
    """
    if view.request.user.is_authenticated():
        storage         = Storage(CredentialsModel, 'id', view.request.user, 'credential')
        view.credential = storage.get()
        # log.info("view.credential %r"%(view.credential,))
        if view.credential is not None:
            if not view.credential.invalid:
                return None         # Valid credential present: proceed...
        else:
            # Django login with local credential: check for user email address
            #
            # @@TODO: is this safe?
            # 
            # NOTE: currently, view.credential is provided by the oauth2 and used
            # only for the .invalid test above.  If it is ever used by other 
            # application components, it may be necessary to construct a
            # credential for local logins.  In the long run, if credentials will
            # be used to access third party services or resources, it may not be 
            # possible to use non-Oauth2 credentials here.  In the meanwhile,
            # allowing local Django user credentials provides an easier route for
            # getting a software instance installed for evaluation purposes.
            #
            if view.request.user.email:
                return None        # Assume valid login: proceed...
            else:
                return error400values(view, "Local user has no email address")
    if not login_form_url:
        return error400values(view, "No login form URI specified")
    if not login_done_url:
        return error400values(view, "No login completion URI specified")
    if not login_post_url:
        login_post_url = login_form_url
    if not continuation_url:
        continuation_url = view.request.path
    # Redirect to initiate login sequence 
    view.request.session['login_form_url']   = login_form_url
    view.request.session['login_post_url']   = login_post_url
    view.request.session['login_done_url']   = login_done_url
    view.request.session['user_profile_url'] = user_profile_url
    view.request.session['continuation_url'] = continuation_url
    view.request.session['oauth2_scope']     = scope
    view.request.session['help_dir']         = os.path.join(settings.SITE_SRC_ROOT, help_path)
    userid = view.request.POST.get("userid", 
        view.request.GET.get("userid",
            view.request.session.get('recent_userid', "")
            )
        ) 
    query_params = (
        { "userid":           userid
        , "continuation_url": continuation_url
        , "scope":            scope
        })
    query_params.update(view.get_message_data())
    return HttpResponseRedirectWithQuery(login_form_url, query_params)

class LoginUserView(generic.View):
    """
    View class to present login form to gather user id and other login information.

    The login page solicits a user id and an identity provider

    The login page supports the following request parameters:

    continuation_url={uri}
    - a URL for a page that is displayed when the login process is complete.
    scope={string}
    - requested or required access scope
    """

    def get(self, request):
        collect_client_secrets()
        # @@TODO: check PROVIDER_FILES, report error if none here
        # Retrieve request parameters
        continuation_url  = request.GET.get("continuation_url", "/no-login-continuation/")
        scope             = request.GET.get("scope",                SCOPE_DEFAULT)
        # Check required values in session - if missing, restart sequence from original URI
        # This is intended to avoid problems if this view is invoked out of sequence
        login_post_url    = request.session.get("login_post_url",   None)
        login_done_url    = request.session.get("login_done_url",   None)
        user_profile_url  = request.session.get("user_profile_url", None)
        help_dir          = request.session.get("help_dir",         None)
        recent_userid     = request.session.get("recent_userid",    "")
        if ( (login_post_url is None) or 
             (login_done_url is None) or 
             (user_profile_url is None) or 
             (help_dir is None) ):
            log.info(
                "@@ redirect post_uri %s, done_uri %s, help_dir %s"%
                (login_post_url, login_done_url, help_dir)
                )
            return HttpResponseRedirect(continuation_url)
        # Display login form
        default_provider = ""
        if len(PROVIDER_FILES.keys()) > 0:
            default_provider = PROVIDER_FILES.keys()[0]
        for p in PROVIDER_DETAILS:
            if "default" in PROVIDER_DETAILS[p]:            
                default_provider = PROVIDER_DETAILS[p]["default"]
        logindata = (
            { "login_post_url":     login_post_url
            , "login_done_url":     login_done_url
            , "user_profile_url":   user_profile_url
            , "continuation_url":   continuation_url
            , "providers":          PROVIDER_FILES.keys()
            , "scope":              scope
            , "suppress_user":      True
            , "provider":           default_provider
            , "help_filename":      "login-help"
            , "userid":             request.GET.get("userid", recent_userid)
            , "info_head":          request.GET.get("info_head", None)
            , "info_message":       request.GET.get("info_message", None)
            , "error_head":         request.GET.get("error_head", None)
            , "error_message":      request.GET.get("error_message", None)
            })
        # Load help text if available
        if "help_filename" in logindata:
            help_filepath = help_dir + "%(help_filename)s.md"%(logindata)
            if os.path.isfile(help_filepath):
                with open(help_filepath, "r") as helpfile:
                    logindata["help_markdown"] = helpfile.read()
        if "help_markdown" in logindata:
            logindata["help_text"] = markdown.markdown(logindata["help_markdown"])
        # Render form & return control to browser
        template = loader.get_template("login.html")
        context  = RequestContext(self.request, logindata)
        return HttpResponse(template.render(context))

class LoginPostView(generic.View):
    """
    View class to initiate an OAuth2 authorization (or similar) flow, typically on 
    POST of a login form.

    It saves the supplied user id in a session value, and redirects the user to the 
    identity provider, which in due course returns control to the application along 
    with a suitable authorization grant.

    The login form provides the following values:

    userid={string}
    - a user identifying string that will be associated with the external service
      login credentials.
    provider={string}
    - a string that identifies a provider selectred to perform authentication
      of the indicated user.  This string is an index to PROVIDER_FILES,
      which in turn contains filenames for client secrets to user when accessing
      the indicated identity provider.
    login_done={uri}
    - a URI that is retrieved, with a suitable authorization grant as a parameter, 
      when appropriate permission has been confirmed by an authenticated user.
      Used to obtain user information following completion of authentication.
      Communicated via a hidden form value.
    user_profile_url={uri}
    - a URI that is retrieved, when user information has been obtained.  Expected use
      is to display user information, thenm continue tyo the page from which the
      login sequence was invoked.  Communicated via a hidden form value.
    continuation_url={uri}
    - URL of page from which logon sequence was invoked, and to which control is
      eventually returned.  Communicated via a hidden form value.
    scope={string}
    - Requested or required access scope, communicated via a hidden form value.
    """

    def post(self, request):
        # Retrieve request parameters
        userid            = request.POST.get("userid",            "")
        provider          = request.POST.get("provider",          "No_provider")
        provider          = request.POST.get("login",             provider)
        login_done_url    = request.POST.get("login_done_url",    "/no_login_done_url_in_form/")
        user_profile_url  = request.POST.get("user_profile_url",  "/no_user_profile_url_in_form/")
        continuation_url  = request.POST.get("continuation_url",  "/no_continuation_url_in_form/")
        scope             = request.POST.get("scope",             SCOPE_DEFAULT) 
        # Access or create flow object for this session
        if request.POST.get("login", None):
            collect_client_secrets()
            provider_details      = PROVIDER_DETAILS[provider]
            provider_details_file = PROVIDER_FILES[provider]
            provider_mechanism    = provider_details.get("mechanism", "OIDC")
            if userid and not re.match(r"\w+$", userid):
                return HttpResponseRedirectLoginWithMessage(
                    request, 
                    "User ID must consist of letters, digits and '_' chacacters (%s)"%(userid), 
                    userid=userid
                    )
            if provider_mechanism == "OIDC":
                # Create and initialize flow object
                flow = flow_from_clientsecrets(
                    provider_details_file,
                    scope=scope,
                    redirect_uri=request.build_absolute_uri(login_done_url)
                    )
                flow.params['state']        = xsrfutil.generate_token(FLOW_SECRET_KEY, request.user)
                flow.params['provider']     = provider
                flow.params['userid']       = userid
                # flow.params['scope']        = scope
                flow.params['continuation'] = continuation_url
                # Save flow object in Django session
                request.session['oauth2flow'] = oauth2_flow_to_dict(flow)
                # Initiate OAuth2 dance
                auth_uri = flow.step1_get_authorize_url()
                return HttpResponseRedirect(auth_uri)
            if provider_mechanism == "django":
                flow = django_flow_from_user_id(
                    provider_details,
                    redirect_uri=request.build_absolute_uri(user_profile_url)
                    )
                # flow.params['state']        = xsrfutil.generate_token(FLOW_SECRET_KEY, request.user)
                # flow.params['provider']     = provider
                flow.params['userid']       = userid
                flow.params['continuation'] = continuation_url
                flow.params['auth_uri']     = reverse("LocalUserPasswordView")
                # Initiate django authentication
                auth_uri = flow.step1_get_authorize_url()
                return HttpResponseRedirect(auth_uri)
            return HttpResponseRedirectLoginWithMessage(
                request,
                "Unrecognized provider mechanism `%s` in %s"%
                (provider_mechanism, provider_details_file), 
                userid=userid
                )
        # Login cancelled: redirect to continuation
        # (which may just redisplay the login page)
        return HttpResponseRedirect(continuation_url)

class LoginDoneView(generic.View):
    """
    View class used to complete login process with authorization grant provided by
    authorization server.
    """

    def get(self, request):
        # Look for authorization grant
        flow   = oauth2_dict_to_flow(request.session['oauth2flow'])
        userid = flow.params['userid']
        # Get authenticated user details
        try:
            credential = flow.step2_exchange(request.REQUEST) # Raises FlowExchangeError if a problem occurs
            authuser = authenticate(
                username=userid, password=credential, 
                profile_uri=PROVIDER_DETAILS[flow.params['provider']]['profile_uri']
                )
        except FlowExchangeError, e:
            log.error("PROVIDER_DETAILS %r"%(PROVIDER_DETAILS[flow.params['provider']],))
            return HttpResponseRedirectLoginWithMessage(request, str(e), userid=userid)
        # Check authenticated details for user id match any previous values.
        #
        # The user id is entered by the user on the login form, and is used as a key to
        # access authenticated user details in the Django user database.  The user id 
        # itself is not checked by the Oauth2 login flow, other than for checking that
        # it containbs only work characters
        #
        # Instead, we trust that the associated email address has been confirmed by the 
        # OAuth2 provider, and don't allow login where the email adress differs from any 
        # currently saved email address for the user id used..  This aims to  prevent a 
        # new set of OAuth2 credentials being used for a previously created Django user id.
        #
        if authuser and not authuser.email:
            return HttpResponseRedirectLoginWithMessage(request, 
                "No email address associated with authenticated user %s"%(userid), 
                userid=userid
                )
        if not userid:
            # Get generated username
            userid = authuser.username
        if not re.match(r"\w+$", userid):
            return HttpResponseRedirectLoginWithMessage(
                request, 
                "User ID must consist of letters, digits and '_' chacacters (%s)"%(userid), 
                userid=userid
                )
        try:
            olduser = User.objects.get(username=userid)
        except User.DoesNotExist:
            olduser = None
        if olduser:
            print "@@ authuser.email %s, olduser.email %s"%(authuser.email, olduser.email)
            if authuser.email != olduser.email:
                return HttpResponseRedirectLoginWithMessage(request, 
                    "Authenticated user %s email address mismatch (%s, %s)"%
                    (userid, authuser.email, olduser.email), 
                    userid=userid
                    )
        # Complete the login and save details
        authuser.save()
        login(request, authuser)
        request.session['recent_userid'] = userid
        storage    = Storage(CredentialsModel, 'id', request.user, 'credential')
        storage.put(credential)
        # Don't normally log the credential/token as they might represent a security leakage:
        # log.debug("LoginDoneView: credential:      "+repr(credential.to_json()))
        # log.info("LoginDoneView: id_token:        "+repr(credential.id_token))
        log.info("LoginDoneView: user.username:   "+authuser.username)
        log.info("LoginDoneView: user.first_name: "+authuser.first_name)
        log.info("LoginDoneView: user.last_name:  "+authuser.last_name)
        log.info("LoginDoneView: user.email:      "+authuser.email)
        return HttpResponseRedirect(flow.params['continuation'])

class LogoutUserView(generic.View):
    """
    View class to handle logout
    """

    def get(self, request):
        recent_userid = request.session.get('recent_userid', "")
        logout(request)
        request.session['recent_userid'] = recent_userid
        continuation_url = request.GET.get("continuation_url", 
            urljoin(urlparse(request.path).path, "../")
            )
        return HttpResponseRedirect(continuation_url)

# End.
